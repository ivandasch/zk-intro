:imagesdir: images
:stem: latexmath
:revealjs_theme: simple
:customcss: style.css
:source-highlighter: highlightjs
:highlightjs-theme:  github.css
:author: Дащинский Иван

= Apache Zookeeper. Паттерны использования.

== Zookeeper основы.
include::parts/foundation.adoc[]

== Клиентское API
include::parts/user_api.adoc[]

== "Введение" в GO ==
include::parts/go.adoc[]

== Рецепты ==
include::parts/recipies.adoc[]

== Zookeeper пример
[cols="3,1", options="header"]
.Lock
|===
|Lock |Unlock
|1. Создать znode `EPHEMERAL_SEQUENTIAL` с именем **locknode/guid-lock-_**.
.4+|Удалить znode, созданную **1**.
|2. Запросить `getChildren( )` у znode **locknode** без установленного watch.
|3. Если znode созданная в пункте **1** имеет самый низкий порядковый номер,
то мьютекс захвачен.
|4. Иначе вызываем `exists( )` с установленным watch на предыдущий узел. Елси `exists( )` возвращает `false`, идем в пункт **2**.
Иначе, ждем нотификации прежде чем идти в пункт **2**.
|===
[plantuml, "election"]
.Выбор лидера
----
start
:Create ""EPHEMERAL_SEQUENTIAL"" **election/guid-**;
repeat :Get child nodes of **election**;
:Get nodes with cnt < ownCnt;
if (nodes empty?) then (yes)
stop
else (no)
endif
backward :Call ""exists"" with watch on previous node;
repeat while
stop
----
== Ignite ZK Structure
[graphviz, "zk-structure"]
.Ignite nodes structure.
-----
digraph ZK {
    graph [ dpi = 150 ];
    node [shape="folder"];
    root[label="<root>"]; n[label="n"]; e[label="e"];
    fj[label="fj-<evt-id>"]
    ce[label="ce"]; cp[label="cp"]; ca[label="ca"];
    jd[label="jd"]; f[label="f-<id>"]; fr[label="fr-<id>"];
    root -> n; root -> e; e -> fj; e -> f; e -> fr;
    root -> ce; root -> cp; root -> ca;
    root -> jd;

}
-----
* **/n/<node-prefix>:<node-uuid>:<flags>|<seq-id>** -- nodes root, children `EPHEMERAL_SEQUENTIAL` -- denoting alive nodes.
* **/jd/<node-prefix>:<node-uuid>[:<part-id>]** -- `PERSISTENT` joining node data
* **/e** -- `PERSISTENT`, serialized `ZkDiscoveryEventsData` topology events.
* **/e/fj-<evt-id>[<part-id>]** -- `PERSISTENT`, serialized grid data for joining node.
* **/e/f-<fut-id>** -- base path for distributed future, children -- node result.
* **/e/fr-<fut-id>** -- result of distributed future.
* **/ce/<event-prefix>:<init-node-id>[:<par-cnt>]|<seq-id>** -- `PERSISTENT_SEQUENTIAL` custom event,
if event message not splitted, save serialized message, otherwise see next step.
* **/cp/<event-prefix>:<init-node-id>[:<par-cnt>]** -- `PERSISTENT` serialized custom event msg, if data splitted.
* **/ca/<event-id>** -- ``PERSISTENT` serialized custom event ack msg (see `DiscoverySpiCustomMessage#ackMessage`).

== Callback & Watcher pattern
[source, java]
----
class ZookeeperDiscoveryImpl {
    void init() {
        zk.getDataAsync(watchedPath, exWatcher, exWatcher);
    }

    class ExampleWatcher implements Watcher, AsyncCallback {
        @Override void process(WatchedEvent e) {
            if (shouldProcess(e)) {
                zk.getDataAsync(e.getPath(), this, this);
            }
        }

        @Override void processResult(int rc, String path, byte[] data) {
            processData(data);
        }
    }

    void processData(byte[] data) {

    }
}
----
== Node join
[plantuml, "server-join"]
-----
participant JoinedNode #lightGreen
participant Coordinator #lightBlue
participant Node
database ZK

JoinedNode --> ZK: ""PERSISTENT"" JoinedData in **/jd/<random-uuid>:<node-uuid>**
JoinedNode --> ZK: ""EPHEMERAL_SEQUENTIAL"" in **/n/<random-uuid>:<node-uuid>:<flags>|<internalOrder>**
JoinedNode --> ZK: Subscribe to **/n**, **/e** and **/ce**
ZK --> Coordinator: Get notification about new ZNodes in **/n** and **/jd**
ZK --> Coordinator: Get JoinedData from **/jd/<random-uuid>:<node-uuid>**
Coordinator --> ZK: ""PERSISTENT"" GridData for JoinedNode in **/e/fj-<evt-id>**
Coordinator --> ZK: ""PERSISTENT""  EventsData in **/e**
ZK --> JoinedNode: Get notification about new ZNodes in **/e**, process GridData
ZK --> Node: Get notification about new ZNodes in **/e**
ZK --> Node: Get JoinedData from **/jd/<random-uuid>:<node-uuid>**, process joined data.
-----
== Send DiscoverySpiCustomMessage
[plantuml, "custom-msg"]
-----
participant SenderNode #lightGreen
participant Coordinator #lightBlue
participant Node
database ZK

SenderNode --> ZK: ""PERSISTENT_SEQUENTIAL"" Event in **/ce/<evt-uuid>:<node-id>:<part-cnt>|<seq>**
SenderNode --> ZK: ""PERSISTENT"" If parts > 1 in **/cp/<evt-uuid>:<node-id>:<part-cnt>**
ZK --> Coordinator: Get notification about new events in **/ce**
Coordinator --> ZK: Get custom events data.
Coordinator --> ZK: ""PERSISTENT"" EventsData in **/e**
ZK --> Node: Got notification about new Events in ZNode **/e**
Node --> ZK: Update lastProcEvent in **/n/<random-uuid>:<node-uuid>:<flags>|<internalOrder>**
ZK --> Coordinator: Notify about data change in **/n**. Coordinator count down acks.
Coordinator --> ZK: Create ack event in **/e**
Coordinator --> ZK: ""PERSISTENT"" Save ack msg data in **/ca**
ZK --> Node: Notify about ack in **/ca**
-----
== Class diagrams. Watchers & Callbacks
[plantuml, "class-diagram"]
----
namespace zk {
    interface Watcher {
        void process(WatchedEvent e)
    }

    interface AsyncCallback

    interface DataCallback {
        void processResult(int rc, String path, Object ctx, byte data[], Stat stat)
    }

    interface Children2Callback {
        void processResult(int rc, String path, Object ctx, List<String> children, Stat stat)
    }

    interface StatCallback {
        void processResult(int rc, String path, Object ctx, Stat stat)
    }

    AsyncCallback <|--- DataCallback
    AsyncCallback <|--- Children2Callback
    AsyncCallback <|--- StatCallback
}

namespace ZkRuntimeState {
    interface ZkWatcher
    interface ZkAliveNodeDataWatcher

    zk.Watcher <|--- ZkWatcher
    zk.DataCallback <|--- ZkWatcher
    zk.Children2Callback <|--- ZkWatcher

    zk.DataCallback <|--- ZkAliveNodeDataWatcher
    zk.Watcher <|--- ZkAliveNodeDataWatcher
}

abstract class ZkAbstractWatcher {
    void process0(WatchedEvent e)
}

zk.Watcher <|--- ZkAbstractWatcher

abstract class ZkAbstractCallback {
    boolean onProcessStart()
    void onStartFailed()
    void onProcessEnd()
    void onProcessError(Throwable e)
}

ZkAbstractCallback <|-- ZkAbstractWatcher

abstract class ZkAbstractChildrenCallback {
    void processResult0(int rc, String path, Object ctx, List<String> children, Stat stat)
}

zk.Children2Callback <|--- ZkAbstractChildrenCallback
ZkAbstractCallback <|--- ZkAbstractChildrenCallback

abstract class PreviousNodeWatcher {
    void onPreviousNodeFail()
}

zk.StatCallback <|--- PreviousNodeWatcher
ZkAbstractWatcher <|--- PreviousNodeWatcher

' Implementations

ZkRuntimeState.ZkWatcher <|-- ZkWatcher
ZkAbstractWatcher <|-- ZkWatcher

ZkRuntimeState.ZkAliveNodeDataWatcher <|--- AliveNodeDataWatcher
ZkAbstractWatcher <|-- AliveNodeDataWatcher

PreviousNodeWatcher <|--- ServerPreviousNodeWatcher
PreviousNodeWatcher <|--- ClientPreviousNodeWatcher
PreviousNodeWatcher <|--- ClientLocalNodeWatcher

ZkAbstractChildrenCallback <|-- CheckCoordinatorCallback
ZkAbstractChildrenCallback <|-- CheckClientsStatusCallback

ZkAbstractWatcher <|--- CheckJoinErrorWatcher
zk.DataCallback <|---  CheckJoinErrorWatcher

----
== Thundering herd problem
[.text-center]
image::thundering_herd.png[width=50%]
Many clients start doing the same job.



